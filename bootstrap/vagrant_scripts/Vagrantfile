# -*- mode: ruby -*-
# vi: set ft=ruby :
# This is a Vagrantfile to automatically provision a local BCPC cluster.

class BCPCBuildError < Vagrant::Errors::VagrantError; end
# NilClass monkey patch so that it's possible to just query #empty? when checking environment variables
class NilClass; def empty?; true; end; end

Vagrant.require_version ">= 1.7.0"

# we need vagrant-triggers now, maybe other plugins in future
required_plugins = %w{vagrant-triggers}
required_plugins.each do |plugin|
  raise BCPCBuildError.new, "#{plugin} plugin is not installed. Please install with 'vagrant plugin install #{plugin}'." unless Vagrant.has_plugin?(plugin)
end

require 'openssl' # used to validate CA certificates
require 'uri' # used to parse the local mirror if one is given

$vdiskmanager = File.join('/', 'Applications', 'VMware Fusion.app', 'Contents', 'Library', 'vmware-vdiskmanager')

# if being run via BOOT_GO.sh, ENV['REPO_ROOT'] will be the root of the repo;
# if it is not set, set it ourselves
ENV['REPO_ROOT'] ||= %x{git rev-parse --show-toplevel}.strip

# pull in the bootstrap config defaults and overrides (even though these would already
# be set by BOOT_GO.sh, do it again here so that Vagrant always has access to all
# configuration variables)
def extract_and_export_envvar(line)
  matches = line.match(/^\s*(?!#)(export |)(?<name>.+)=(?<value>.+)$/)
  unless matches.nil?
    name, value = matches[:name], matches[:value]
    # this blob interpolates existing environment variables in
    interpolated_value = value.dup
    envvars_to_interpolate = interpolated_value.scan /\$\w+/
    envvars_to_interpolate.flatten.each {|v| interpolated_value.gsub!(v, ENV[v.tr('$', '')])}
    explanation = (ENV[name] ? "Overriding " : "Setting ") + "#{name} = #{interpolated_value}"
    explanation << " (originally #{value})" if interpolated_value != value
    # puts explanation
    ENV[name] = interpolated_value
  end
end

config_path = File.join ENV['REPO_ROOT'], 'bootstrap', 'config'
config_defaults = File.join(config_path, 'bootstrap_config.sh.defaults')
config_overrides = File.join(config_path, 'bootstrap_config.sh.overrides')

File.open(config_defaults).each do |line|
    extract_and_export_envvar(line)
end
if File.exist?(config_overrides)
  File.open(config_overrides).each do |line|
      extract_and_export_envvar(line)
  end
end

# test required environment variables after config import
%w{
  BCPC_VM_DIR
  BOOTSTRAP_CACHE_DIR
  BOOTSTRAP_DOMAIN
  BOOTSTRAP_VM_CPUS
  BOOTSTRAP_VM_MEM
  CLUSTER_VM_CPUS
  CLUSTER_VM_DRIVE_SIZE
  CLUSTER_VM_MEM
  FILECACHE_MOUNT_POINT
  REPO_MOUNT_POINT
  REPO_ROOT
}.each do |v|
  raise BCPCBuildError.new, "#{x} must be set in the environment. Please check your bootstrap configuration." if ENV[v].empty?
end

unless ENV['BCPC_VM_DIR'].empty?
  # VAGRANT_VMWARE_CLONE_DIRECTORY is a special envvar used by the VMware provider
  ENV['VAGRANT_VMWARE_CLONE_DIRECTORY'] = ENV['BCPC_VM_DIR']
end

case ENV['BOOTSTRAP_VM_PROVIDER']
when 'vmware'
  ENV['VAGRANT_DEFAULT_PROVIDER'] = (RUBY_PLATFORM.downcase.include? 'darwin') ? 'vmware_fusion' : 'vmware_workstation'
  #$box_url = "#{ENV['BOOTSTRAP_CACHE_DIR']}/vmware_desktop.box"
  $box_url = "/Users/erhudy/Desktop/ubuntu-14-04-x64-vmware.box"
else
  puts "Provider not set or not supported, defaulting to VirtualBox." unless ENV['BOOTSTRAP_VM_PROVIDER'] == 'virtualbox'
  ENV['VAGRANT_DEFAULT_PROVIDER'] = 'virtualbox'
  $box_url = "#{ENV['BOOTSTRAP_CACHE_DIR']}/trusty-server-cloudimg-amd64-vagrant-disk1.box"
end

# list any package names to be automatically removed here
$packages_to_remove = []

# if a directory with additional CA certs is provided, test each file in there to
# verify that it's a certificate ending in .crt (due to update-ca-certificates restrictions)
# and then add it to a script to be run inside each VM
# script will also test the file to see if it appears to contain multiple certificates,
# which update-ca-certificates does not seem to handle reliably
$update_ca_certificates_script = ""
unless ENV['BOOTSTRAP_ADDITIONAL_CACERTS_DIR'].empty?
  cacerts_dir = Dir.new(ENV['BOOTSTRAP_ADDITIONAL_CACERTS_DIR'])
  files_in_cacerts_dir = cacerts_dir.entries.select{|e| not ['.', '..'].include? e}
  files_in_cacerts_dir.each do |f|
    begin
      unless f.end_with? '.crt'
        raise BCPCBuildError.new, "All files in #{ENV['BOOTSTRAP_ADDITIONAL_CACERTS_DIR']} must end in .crt due to update-ca-certificates restrictions."
      end
      cert_raw = File.read(File.join(ENV['BOOTSTRAP_ADDITIONAL_CACERTS_DIR'], f))
      if cert_raw.scan('-----BEGIN CERTIFICATE-----').length > 1
        raise BCPCBuildError.new, "Multiple certificates detected in #{File.join(ENV['BOOTSTRAP_ADDITIONAL_CACERTS_DIR'], f)}, please split them into separate certificates."
      end
      cert = OpenSSL::X509::Certificate.new(cert_raw) # test that the cert is valid
      dest_cert_path = File.join('/usr/local/share/ca-certificates', f)
      $update_ca_certificates_script << <<-EOH
        echo -e "#{cert_raw}" > #{dest_cert_path}
      EOH
    rescue OpenSSL::X509::CertificateError
      raise BCPCBuildError.new, "Certificate #{File.join(ENV['BOOTSTRAP_ADDITIONAL_CACERTS_DIR'], f)} is not a valid PEM certificate, aborting."
    end
  end
  $update_ca_certificates_script << <<-EOH
    update-ca-certificates
  EOH
end

# if proxies are provided, configure them before configuring any local mirror override
# RUN THIS SCRIPT WITH sudo AND privileged = false so that $HOME is set to the
# value of the non-root user
$proxy_configuration_script = <<-EOH
  sudo touch /etc/apt/apt.conf
  touch $HOME/proxy_config.sh
EOH
unless ENV['BOOTSTRAP_HTTP_PROXY'].empty?
  $proxy_configuration_script << <<-EOH
    echo 'Acquire::http::Proxy "http://#{ENV['BOOTSTRAP_HTTP_PROXY']}";' | sudo tee -a /etc/apt/apt.conf
    echo 'export http_proxy=#{ENV['BOOTSTRAP_HTTP_PROXY']}' | tee -a $HOME/proxy_config.sh
  EOH
end
unless ENV['BOOTSTRAP_HTTPS_PROXY'].empty?
  $proxy_configuration_script << <<-EOH
    echo 'Acquire::https::Proxy "https://#{ENV['BOOTSTRAP_HTTPS_PROXY']}";' | sudo tee -a /etc/apt/apt.conf
    echo 'export https_proxy=#{ENV['BOOTSTRAP_HTTPS_PROXY']}' | tee -a $HOME/proxy_config.sh
  EOH
end

# this script tests proxy servers from inside the bootstrap node
$testing_proxy_servers_script = <<-EOH
  . $HOME/proxy_config.sh
  FAILED=0
  HTTP_PROXY_TEST=$(curl http://www.google.com 2>&1)
  if [[ $? != 0 ]]; then
    echo "HTTP proxy test failed, check HTTP proxy configuration:"
    echo -e "$HTTP_PROXY_TEST"
    FAILED=1
  fi
  HTTPS_PROXY_TEST=$(curl https://github.com 2>&1)
  if [[ $? != 0 ]]; then
    echo -e "HTTPS proxy test failed, check HTTPS proxy configuration and SSL certificates:"
    echo -e "$HTTPS_PROXY_TEST"
    FAILED=1
  fi
  exit $FAILED
EOH

# compute the repository configuration script
$repos_script = <<-EOH
  #!/bin/bash
  hash -r
  install -d -m0755 -g adm /var/log/vagrant
  exec &>>/var/log/vagrant/provision.log
  date --rfc-3339=s
EOH

unless ENV['BOOTSTRAP_APT_MIRROR'].empty?
  local_mirror_host = URI(ENV['BOOTSTRAP_APT_MIRROR']).host
  raise BCPCBuildError.new, "#{ENV['BOOTSTRAP_APT_MIRROR']} is an invalid URL, aborting build" if local_mirror_host.nil?
  $repos_script << <<-EOH
    cp /etc/apt/sources.list /etc/apt/sources.list.bak
    sed -r -i 's|http://archive\.ubuntu\.com/ubuntu|#{ENV['BOOTSTRAP_APT_MIRROR']}|g' /etc/apt/sources.list
    sed -r -i 's|http://us\.archive\.ubuntu\.com/ubuntu|#{ENV['BOOTSTRAP_APT_MIRROR']}|g' /etc/apt/sources.list
    sed -r -i 's|http://security\.ubuntu\.com/ubuntu|#{ENV['BOOTSTRAP_APT_MIRROR']}|g' /etc/apt/sources.list
    sed -r -i s/^deb-src/\#deb-src/g /etc/apt/sources.list
    egrep -v '^$|^#' /etc/apt/sources.list | tee /etc/apt/sources.list
    touch /etc/apt/apt.conf
    echo 'Acquire::http::Proxy::#{local_mirror_host} "DIRECT";' | tee -a /etc/apt/apt.conf
  EOH
end

# try to apt-get update immediately so that the bootstrap does not wander along for a while
# and waste everyone's time in case the repository configuration is broken
$repos_script << <<-EOH
  apt-get update
EOH
# END repository configuration script

# since these boxes do not come with swap, this script will add a swap file on disk
# (repartionining /dev/sda would be a dreadful chore)
$add_swap_script = <<-EOH
  #!/bin/bash
  fallocate -l 8192M /swap >/dev/null
  chmod 600 /swap >/dev/null
  mkswap /swap >/dev/null
  swapon /swap >/dev/null
  echo '/swap none swap defaults 0 0' | tee -a /etc/fstab >/dev/null
EOH

Vagrant.configure("2") do |config|
  # build list of all machines to provision at once
  cluster_nodes = 3
  monitoring_node_count = ENV['MONITORING_NODES'].to_i
  # nil.to_i is 0, so no need to check for nil explicitly
  unless monitoring_node_count == 0
    if (1..3).include? monitoring_node_count
      cluster_nodes += monitoring_node_count
    else
      raise BCPCBuildError.new, "Invalid number of monitoring nodes specified (1-3 allowed)"
    end
  end
  # ENV['CLUSTER_NODE_COUNT_OVERRIDE'] is a safety valve used by vagrant_clean.sh
  # to always clean up the maximal count of VMs (e.g., try to clean monitoring
  # nodes even if the script isn't sure any were made)
  if ENV['CLUSTER_NODE_COUNT_OVERRIDE'].to_i > 0
    cluster_nodes = ENV['CLUSTER_NODE_COUNT_OVERRIDE'].to_i
    # puts "Cluster node count is being overridden to #{cluster_nodes} via CLUSTER_NODE_COUNT_OVERRIDE"
  end

  vms_to_build = ['bootstrap', (1..cluster_nodes).collect {|x| "vm#{x}"}].flatten

  vms_to_build.each_with_index do |vm, idx|
    config.vm.define vm do |m|
      # use .3 as the final octet for the bootstrap node, otherwise 11, 12, etc.
      final_octet = (vm == 'bootstrap' ? 3 : 10+idx)
      bootstrap_domain = (ENV['BCPC_HYPERVISOR_DOMAIN'] or "hypervisor-bcpc.example.com")
      m.vm.hostname = "bcpc-#{vm}.#{bootstrap_domain}"
      m.vm.network :private_network, ip: "10.0.100.#{final_octet}", netmask: "255.255.255.0", adapter_ip: "10.0.100.2"
      m.vm.network :private_network, ip: "172.16.100.#{final_octet}", netmask: "255.255.255.0", adapter_ip: "172.16.100.2"
      m.vm.network :private_network, ip: "192.168.100.#{final_octet}", netmask: "255.255.255.0", adapter_ip: "192.168.100.2"

      m.vm.synced_folder(ENV['REPO_ROOT'], ENV['REPO_MOUNT_POINT'])
      m.vm.synced_folder(ENV['BOOTSTRAP_CACHE_DIR'], ENV['FILECACHE_MOUNT_POINT'])
      m.vm.synced_folder ".", "/vagrant", disabled: true

      # fix no-tty error
      m.vm.provision "fix-no-tty", type: "shell" do |s|
        s.privileged = false
        s.inline = "sudo sed -i '/tty/!s/mesg n/tty -s \\&\\& mesg n/' /root/.profile"
      end

      # configure extra CA certificates
      m.vm.provision "configure-ca-certificates", type: "shell" do |s|
        s.inline = $update_ca_certificates_script
      end

      # configure proxy servers (do not run as root)
      m.vm.provision "configure-proxy-servers", type: "shell" do |s|
        s.privileged = false
        s.inline = $proxy_configuration_script
      end

      # from bootstrap node only: test proxy servers from inside to determine whether
      # everything's set up properly
      if vm == 'bootstrap'
        m.vm.provision "testing-proxy-servers", type: "shell" do |s|
          s.privileged = false
          s.inline = $testing_proxy_servers_script
        end
      end

      # set up repositories
      m.vm.provision "configure-repositories", type: "shell" do |s|
        s.inline = $repos_script
      end

      # configure a hostfile entry with the IP of the bootstrap node (for Chef)
      m.vm.provision "configure-bootstrap-hostfile-entry", type: "shell" do |s|
        s.inline = "echo -e '10.0.100.3\tbcpc-bootstrap.#{bootstrap_domain}\n' >> /etc/hosts"
      end

      # clean up some packages installed in this image by default
      m.vm.provision "clean-up-unnecessary-packages", type: "shell" do |s|
        s.inline = "apt-get remove -y #{$packages_to_remove.join(' ')}"
      end if $packages_to_remove.length > 0

      # add swap space
      m.vm.provision "add-swap-space", type: "shell" do |s|
        s.inline = $add_swap_script
      end

      m.vm.box = "#{ENV['VAGRANT_DEFAULT_PROVIDER']}-trusty64"
      m.vm.box_url = $box_url

      if vm == 'bootstrap'
        memory = ENV["BOOTSTRAP_VM_MEM"]
        cpus = ENV["BOOTSTRAP_VM_CPUS"]
      else
        memory = ENV["CLUSTER_VM_MEM"]
        cpus = ENV["CLUSTER_VM_CPUS"]
        disk_size = ENV["CLUSTER_VM_DRIVE_SIZE"]
      end

      case ENV['VAGRANT_DEFAULT_PROVIDER']
      when 'virtualbox'
        m.vm.provider :virtualbox do |vb|
          vb.name = "bcpc-#{vm}"
          vb.memory = memory
          vb.cpus = cpus

          vb.customize ["modifyvm", :id, "--nictype2", "82543GC"]
          vb.customize ["modifyvm", :id, "--vram", "16"]
          vb.customize ["modifyvm", :id, "--largepages", "on"]
          vb.customize ["modifyvm", :id, "--nestedpaging", "on"]
          vb.customize ["modifyvm", :id, "--vtxvpid", "on"]
          vb.customize ["modifyvm", :id, "--hwvirtex", "on"]
          vb.customize ["modifyvm", :id, "--ioapic", "on"]

          # this attaches extra disks to the first 3 non-bootstrap nodes (additional cluster
          # nodes are assumed to be monitoring, which do not need extra disks)
          if (1..3).include?(idx)
            # this is an unpleasing hack to locate the VM on disk, so that additional disks can be stored with it
            # this assumes that all VMs will be going into the default VirtualBox folder
            begin
              default_vm_config_file = %x[VBoxManage list systemproperties | grep 'Default machine folder']
              default_vm_loc = default_vm_config_file.match(/^Default machine folder:\s+(.+)$/)[1]
              vm_dir = File.join(default_vm_loc, vm)
            rescue
              raise BCPCBuildError.new, "Unable to locate VM #{vm} on disk, terminating"
            end

            ('b'..'e').each_with_index do |disk, disk_idx|
              disk_file = File.join(vm_dir, "#{vm}-#{disk}.vdi")
              unless File.exist?(disk_file)
                vb.customize ["createhd", "--filename", disk_file, "--size", disk_size]
                vb.customize ["storageattach", :id, "--storagectl", "SATAController", "--device", "0", "--port", "#{disk_idx+1}", "--type", "hdd", "--medium", disk_file]
              end # unless File.exist?(disk_file)
            end # ('b'..'e').each_with_index do |disk, disk_idx|
          end # if (1..3).include? idx
        end # m.vm.provider :virtualbox do |vb|
      when 'vmware_fusion', 'vmware_workstation'
        m.vm.provider ENV['VAGRANT_DEFAULT_PROVIDER'].to_sym do |vw|
          vw.vmx['displayname'] = "bcpc-#{vm}"
          vw.vmx['memsize'] = memory
          vw.vmx['numvcpus'] = cpus
        end # m.vm.provider ENV['VAGRANT_DEFAULT_PROVIDER'].to_sym do |vw|
      end # case ENV['VAGRANT_DEFAULT_PROVIDER']
    end # config.vm.define vm do |machine|
  end # $vms_to_build.each_with_index
end # Vagrant.configure("2") do |config|
